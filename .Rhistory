install.packages("swirl")
library("swirl")
swirl()
5 + 7
X <- 5 + 7
x <- 5 + 7
x
y <- x - 3
y
z <- c(1.1, 9, 3.14)
?c
z
c(z, 555, z)
z * 2 + 100
my_sqrt <- sqrt(z - 1)
my_sqrt
my_div <- z/my_sqrt
my-div
my_div
C(1,2,3,4) + c(0,10)
c(1,2,3,4) + c(0,10)
c(1, 2, 3, 4) + c(0, 10, 100)
z * 2 + 1000
my_div
5 + 7
x <- 5+7
x
y <- x - 3
y
c (1.1,9,3.14)
z <- c(1.1,9,3.14)
?c
z
c(z,555,z)
z*2+100
my_sqrt <- sqrt(z-1)
my_sqrt
my_div <- z/my_sqrt
my_div
c(1, 2, 3, 4) + c(0,10)
c(1,2,3,4) + c(0,10,100)
z*2+1000
my_div
getwd()
ls()
x<-9
ls()
list.files()
?list.files
args(list.files)
old.dir <- getwd()
dir.create(testdir)
dir.create("testdir")
setwd("testdir")
file.creat("mytest.R")
file.create("mytest.R")
ls()
list.files()
file.exists("mytest.R")
file.info("mytest.R")
play()
args(file.rename)
nxt()
file.rename("mytest.R","mytest2.R")
file.copy("mytest2.R","mytest3.R")
file.path("mytest3.R")
play()
args(file.path)
?file.path
nxt()
file.path("folder1","folder2")
?dir.create
dir.create(filepath("testdir2", "testdir3"),recursive=TRUE)
dir.create(file.path("testdir2","testdir3"),recursive = TRUE)
play()
?unlink
nxt()
unlink("testdir2",recursive = TRUE)
setwd(old.dir)
unlink("testdir",TRUE)
cube(3)
cube <- function(x,n) {
x^3
}
cube(3)
cube(2)
cube(1)
x <- 1:10
if(x > 5) {
x <- 0
}
f <- function(x) {
g <- function(y) {
y + z
}
z <- 4
x + g(x)
}
z <- 10
f(3)
x <- 5
y <- if(x < 3) {
NA
} else {
10
}
y
?parent.frame
x <- 1:10
if(x[1] > 5) {
x <- 0
}
x
x <- 1:10
if(x[6] > 5) {
x <- 0
}
x
getwd()
?download.file
?unzip
source('~/pollutantmean.R')
pullutantmean("specdata", "sulfate", 1:10)
pollutantmean("specdata", "sulfate", 1:10)
source('~/pollutantmean.R')
pollutantmean("specdata", "sulfate", 1:10)
source('~/pollutantmean.R')
pollutantmean("specdata", "sulfate", 1:10)
getwd()
source('~/pollutantmean.R')
pollutantmean("specdata", "sulfate", 1:10)
source('~/pollutantmean.R')
pollutantmean("specdata", "sulfate", 1:10)
source('~/pollutantmean.R')
pollutantmean("specdata", "sulfate", 1:10)
source('~/pollutantmean.R')
source('~/pollutantmean.R')
pollutantmean("specdata", "sulfate", 1:10)
source('~/pollutantmean.R')
pollutantmean("specdata", "sulfate", 1:10)
source('~/pollutantmean.R')
pollutantmean("specdata", "sulfate", 1:10)
source('~/pollutantmean.R')
pollutantmean("specdata", "sulfate", 1:10)
library(datasets)
data(iris)
?iris
x <- iris[,1]
x
y <- iris[,5]
y
tapply(x,y,mean)
tapply(iris[,1],iris[,5],mean)
tapply(iris,iris[,5],mean)
tapply(iris$Sepal.Length, iris$Species, mean)
apply(iris[,1:4],2,mean)
apply(iris[, 1:4], 1, mean)
rowMeans(iris[, 1:4])
apply(iris, 2, mean)
library(datasets)
data(mtcars)
?mtcars
mtcars
mtcars
tapply(mtcars$mpg, mtcars$cyl, mean)
split(mtcars, mtcars$cyl)
with(mtcars, tapply(mpg, cyl, mean))
lapply(mtcars, mean)
mean(mtcars$mpg, mtcars$cyl)
?str
split(mtcars$hp,mtcars$cyl)
tapply(mtcars$hp,mtcars$cyl,mean)
x <- tapply(mtcars$hp,mtcars$cyl,mean)
abs(x[1],x[3])
?abs
abs(x[1] - x[3])
debug(ls)
ls
ls()
m <- matrix(1:4, nrow=2, ncol=3)
m <- matrix(1:4, nrow=2, ncol=2)
m
solve(m)
m*solve(m)
?solve
?matrix
source('~/ProgrammingAssignment2/cachematrix.R')
source('~/ProgrammingAssignment2/cachematrix.R')
cachematrix(m)
makeCacheMatrix(m)
m
a <- makeCacheMatrix()
a$get(m)
a$get()
a$set(m)
a$get(m)
a$get
a <- makeCacheMatrix(m)
a$get
a$set(m)
a$get
a$get()
a$setmean(m)
a$getmean(m)
a$getmean()
source('~/ProgrammingAssignment2/cachematrix.R')
a$getmean()
a$setInverse(m)
a$setInverse(10)
source('~/ProgrammingAssignment2/cachematrix.R')
a$setInverse(10)
source('~/ProgrammingAssignment2/cachematrix.R')
a$setInverse(10)
source('~/ProgrammingAssignment2/cachematrix.R')
a$setmean(10)
a$getmean()
source('~/ProgrammingAssignment2/cachematrix.R')
a$setInverse(10)
?setmean
?getmean
?setInverse
source('~/ProgrammingAssignment2/cachematrix.R')
source('~/ProgrammingAssignment2/cachematrix.R')
a$setmean(7)
a$getmean()
source('~/ProgrammingAssignment2/cachematrix.R')
a$getmean()
a$setmean(3)
a$getmean()
source('~/ProgrammingAssignment2/cachematrix.R')
a <- makeCacheMatrix(m)
a$setinverse(4)
a$getmean()
source('~/ProgrammingAssignment2/cachematrix.R')
a <- makeCacheMatrix(m)
a$setInverse(4)
a$getInverse()
a$set
a$set(1:4)
a$get()
a$set(matrix(2:5,nrow=2, ncol=2))
a$get()
source('~/ProgrammingAssignment2/cachematrix.R')
source('~/ProgrammingAssignment2/cachematrix.R')
b <- cacheSolve(m)
b
m
cacheSolve(m)
source('~/ProgrammingAssignment2/cachematrix.R')
cacheSolve(m)
source('~/ProgrammingAssignment2/cachematrix.R')
source('~/ProgrammingAssignment2/cachematrix.R')
cacheSolve(m)
cacheSolve(makeCacheMatrix(m))
cacheSolve(a)
source('~/ProgrammingAssignment2/cachematrix.R')
cacheSolve(makeCacheMatrix(m))
source('~/ProgrammingAssignment2/cachematrix.R')
cacheSolve(makeCacheMatrix(m))
cacheSolve(makeCacheMatrix(m))
cacheSolve(makeCacheMatrix(matrix(4:7,nrow=2,ncol=2)))
source('~/ProgrammingAssignment2/cachematrix.R')
cacheSolve(makeCacheMatrix(matrix(4:7,nrow=2,ncol=2)))
cacheSolve(makeCacheMatrix(matrix(2:6,nrow=2,ncol=2)))
message?
?
''
?message
cacheSolve(a)
a <- makeCacheMatrix(m)
a
cacheSolve(a)
cacheSolve(a)
cacheSolve(a)
b < makeCacheMatrix(matrix(100:103,nrow=2,ncol=2))
m2 <- matrix(100:103,nrow=2,ncol=2)
m2
b <- makeCacheMatrix(m2)
cacheSolve(b)
m3 <- matrix(1:9,nrow=3,ncol=3)
m3
c < makeCacheMatrix(m3)
c <- makeCacheMatrix(m3)
cacheSolve(c)
m3 <- cbind(c(1,0,0),c(0,1,0),c(0,0,1))
m3
c <- makeCacheMatrix(m3)
cacheSolve(c)
cacheSolve(c)
?solve
m <- matrix(c(-1, -2, 1, 1), 2,2)
x <- makeCacheMatrix(m)
x$get()
source('~/ProgrammingAssignment2/cachematrix.R')
source('~/ProgrammingAssignment2/cachematrix.R')
x$get()
x <- makeCacheMatrix(m)
x$get()
inv <- cacheSolve(x)
inv
inv <- cacheSolve(x)
inv
## Use a time test to see if we really save time
##
n <- 128
mat <- matrix(rnorm(1:(n*n)), nrow=n, ncol=n)
matCached <- makeCacheMatrix(mat)
time1 <- system.time(matSolved1 <- cacheSolve(matCached))
time2 <- system.time(matSolved2 <- cacheSolve(matCached))
if (time1["user.self"] < time2["user.self"])
message("Solve time is less than cache time")
source('~/ProgrammingAssignment2/cachematrix.R')
message("Solve time is NOT less than cache time")
## Use a time test to see if we really save time
##
n <- 128
mat <- matrix(rnorm(1:(n*n)), nrow=n, ncol=n)
matCached <- makeCacheMatrix(mat)
time1 <- system.time(matSolved1 <- cacheSolve(matCached))
time2 <- system.time(matSolved2 <- cacheSolve(matCached))
if (time1["user.self"] < time2["user.self"])
message("Solve time is less than cache time")
## Use a time test to see if we really save time
##
n <- 128
mat <- matrix(rnorm(1:(n*n)), nrow=n, ncol=n)
matCached <- makeCacheMatrix(mat)
time1 <- system.time(matSolved1 <- cacheSolve(matCached))
time2 <- system.time(matSolved2 <- cacheSolve(matCached))
if (time1["user.self"] < time2["user.self"])
message("Solve time is less than cache time")
source('~/ProgrammingAssignment2/cachematrix.R')
message("Solve time is more than cache time")
## Test basic caching
##
n <- 3
mat <- matrix(rnorm(1:(n*n)), nrow=n, ncol=n)
matCached <- makeCacheMatrix(mat)
matSolved1 <- cacheSolve(matCached)
matSolved2 <- cacheSolve(matCached)
if (!identical(matSolved1, matSolved2))
message("Cached version does not match solved version")
## Test basic caching
##
n <- 3
mat <- matrix(rnorm(1:(n*n)), nrow=n, ncol=n)
matCached <- makeCacheMatrix(mat)
matSolved1 <- cacheSolve(matCached)
matSolved2 <- cacheSolve(matCached)
if (!identical(matSolved1, matSolved2))
message("Cached version does not match solved version")
## This really just tests to see if the matrix inverse is computed
## correctly, which is more of a test of the solve() function. Multiply the
## original matrix by the inverse.  Subtract the identity and the result
## should be a zero matrix, within the limits of machine precision.
##
## Note that the allowable error will be much more than machine epsilon due
## to the large number of operations in solve(), which is O(n^3).  Each
## element in the matrix won't be subjected to n^3 operations, but n^3
## is a decent upper bound.
##
n <- 20
mat <- matrix(rnorm(1:(n*n)), nrow=n, ncol=n)
matCached <- makeCacheMatrix(mat)
matSolved <- cacheSolve(matCached)
tmp <- mat %*% matSolved
tmp <- abs(tmp - diag(n))
b <- tmp > (.Machine$double.eps * n^3)
if (sum(b) != 0)
message("Incorrect matrix inversion")
## Test some of the internals
##
if (!identical(mat, matCached$get()))
message("get() not working")
if (!identical(matSolved, matCached$getSolved()))
message("getSolved() not working")
n <- 5
mat <- matrix(rnorm(1:(n*n)), nrow=n, ncol=n)
matCached$set(mat)
if (!identical(mat, matCached$get()))
message("get() after set() not working")
if (!is.null(matCached$getSolved()))
message("getSolved() after set() not working")
## This really just tests to see if the matrix inverse is computed
## correctly, which is more of a test of the solve() function. Multiply the
## original matrix by the inverse.  Subtract the identity and the result
## should be a zero matrix, within the limits of machine precision.
##
## Note that the allowable error will be much more than machine epsilon due
## to the large number of operations in solve(), which is O(n^3).  Each
## element in the matrix won't be subjected to n^3 operations, but n^3
## is a decent upper bound.
##
n <- 20
mat <- matrix(rnorm(1:(n*n)), nrow=n, ncol=n)
matCached <- makeCacheMatrix(mat)
matSolved <- cacheSolve(matCached)
tmp <- mat %*% matSolved
tmp <- abs(tmp - diag(n))
b <- tmp > (.Machine$double.eps * n^3)
if (sum(b) != 0)
message("Incorrect matrix inversion")
## Test some of the internals
##
if (!identical(mat, matCached$get()))
message("get() not working")
if (!identical(matSolved, matCached$getInverse()))
message("getInverse() not working")
n <- 5
mat <- matrix(rnorm(1:(n*n)), nrow=n, ncol=n)
matCached$set(mat)
if (!identical(mat, matCached$get()))
message("get() after set() not working")
if (!is.null(matCached$getInverse()))
message("getInverse() after set() not working")
source('~/ProgrammingAssignment2/cachematrix.R')
## Test basic caching
##
n <- 3
mat <- matrix(rnorm(1:(n*n)), nrow=n, ncol=n)
matCached <- makeCacheMatrix(mat)
matSolved1 <- cacheSolve(matCached)
matSolved2 <- cacheSolve(matCached)
if (!identical(matSolved1, matSolved2))
message("Cached version does not match solved version")
source('~/ProgrammingAssignment2/cachematrix.R')
## Test basic caching
##
n <- 3
mat <- matrix(rnorm(1:(n*n)), nrow=n, ncol=n)
matCached <- makeCacheMatrix(mat)
matSolved1 <- cacheSolve(matCached)
matSolved2 <- cacheSolve(matCached)
if (!identical(matSolved1, matSolved2))
message("Cached version does not match solved version")
source('~/ProgrammingAssignment2/cachematrix.R')
source('~/ProgrammingAssignment2/cachematrix.R')
source('~/ProgrammingAssignment2/cachematrix.R')
source('~/ProgrammingAssignment2/cachematrix.R')
source('~/ProgrammingAssignment2/cachematrix.R')
m <- matrix(c(-1,-2,1,2),2,2)
m
m <- matrix(c(-1,-2,2,1),2,2)
m
a <- makeCacheMatrix(m)
source('~/ProgrammingAssignment2/cachematrix.R')
a <- makeCacheMatrix(m)
cacheSolve(a)
m <- matrix(c(-1,-2,2,1),2,2)
a <- makeCacheMatrix(m)
cacheSolve(a)
cacheSolve(a)
m <- matrix(c(1,0,0,1),2,2)
cacheSolve(a)
a <- makeCacheMatrix(m)
cacheSolve(a)
cacheSolve(a)
m <- matrix(c(-1,-2,1,2),2,2)
a <- makeCacheMatrix(m)
cacheSolve(a)
m <- matrix(c(-1,2,-2,1),2,2)
a <- makeCacheMatrix(m)
cacheSolve(a)
cacheSolve(a)
source('~/ProgrammingAssignment2/cachematrix.R')
makeCacheMatrix(matrix(3:11, nrow=3, ncol=3))
x <- makeCacheMatrix(matrix(3:11, nrow=3, ncol=3))
cacheSolve(x)
x <- makeCacheMatrix(matrix(0:8, nrow=3, ncol=3))
cacheSolve(x)
x <- makeCacheMatrix(matrix(1:1, nrow=3, ncol=3))
cacheSolve(x)
x <- makeCacheMatrix(matrix(c(1,3,2,6,2,9,2,5,3), nrow=3, ncol=3))
cacheSolve(x)
source('~/ProgrammingAssignment2/cachematrix.R')
x <- makeCacheMatrix(matrix(c(1,3,2,6,2,9,2,5,3), nrow=3, ncol=3))
cacheSolve(x)
